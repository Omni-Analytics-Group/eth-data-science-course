---
title: "Analyzing Snapshot Rankings: Short-term and Long-term Priorities for Arbitrum
  DAO"
author: "Omniacs.DAO"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
    toc_depth: '3'
  html_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
---
<!-- Custom Background and Output Styling -->
<style>
body {
  background-image: url('background_02.png');
  background-size: cover;
  background-attachment: fixed;
  background-repeat: no-repeat;
  background-position: center;
  margin: 0;
  padding: 0;
}

.main-container {
  background-color: rgba(255, 255, 255, 0.975);
  padding: 30px;
  border-radius: 10px;
  max-width: 900px;
  margin: auto;
  box-shadow: 0px 0px 10px rgba(0,0,0,0.2);
}

/* Optional: Output box styling */
.output-box {
  border: 2px solid #18bc9c;
  background: #eafaf1;
  padding: 12px;
  margin: 1em 0;
  border-radius: 6px;
  font-size: 1.08em;
  font-family: "Fira Mono", "Menlo", "Monaco", "Consolas", monospace;
  white-space: pre-wrap;
}
</style>

<img src="../../Shot_Poses_IACS/OmniacPoses_30.png" width="120" style="float:right; margin: 8px 0 8px 20px;">

# Project Overview

## Objective

This analysis helps **Plurality Labs** and the **Arbitrum DAO** compare strategic framework results on two platforms—**Ethelo** and **Snapshot**. The aim is to determine which channel yields the best quality input. We focus on:

- Comparing contributions by delegate and general contributor wallets
- Revealing similarities and differences in priorities
- Enabling data-driven refinement of the strategic framework
- Sharing all results on a public hub

## Activities & Timeline

- **Data procurement**: Collect aggregate Snapshot data
- **Data processing**: Format and clean for analysis
- **Feature engineering**: Calculate new summary metrics
- **Ranking scheme**: Develop both equal-weighted and token-weighted rankings
- **Analysis**: Compare how priorities differ depending on weighting
- **Sharing**: Publish data and analysis


<img src="../../Shot_Poses_IACS/OmniacPoses_31.png" width="120">

# Background

During #GovMonth, contributors ranked statements related to “Growth and Innovation” and ways Arbitrum could “Reduce Friction”. Respondents ordered statements by preference. The main questions:

**Growth + Innovation Statements**

1. Develop accountability practices within ArbitrumDAO.
2. Identify the key capabilities for improved DAO performance.
3. Form alliances with legacy institutions.
4. Fund projects for cross-chain compatibility.
5. Improve gas fee optimization.
6. Define growth strategies.
7. Incentivize users and builders.
8. Scale the platform.
9. Offer educational opportunities.
10. Evolve governance capabilities.

**Reducing Friction Statements**

1. Build a robust developer community.
2. Make Arbitrum more accessible for developers.
3. Create an inclusive environment.
4. Encourage meaningful DAO participation.
5. Raise awareness of opportunities.
6. Prioritize gas fee optimization.
7. Ensure regulatory compliance.
8. Build anti-Sybil protections.
9. Uphold transparency.
10. Improve token distribution equity.

Each respondent's data includes their wallet, rankings, and Arbitrum holdings (for weighting). Below is a snippet of the GovMonth proposal. For this task, voters were prompted with two sets of statements related to “Growth and Innovation” and ways Arbitrum could “Reduce Friction”.  The survey respondents were to rank order each statement according to their personal preference. The statements for each are as follows:

<img src="../../images/govmonth.png" width="600" style="display:block; margin-left:auto; margin-right:auto;">



# Libraries and Setup

Below, we load the necessary `R` packages for web requests, data wrangling, and working with GraphQL APIs.

```{r setup, message=FALSE, warning=FALSE}
# Load essential libraries
library(jsonlite)   # For parsing JSON data
library(httr)       # For making web requests (not always required, but useful)
library(lubridate)  # For handling date-times
library(ghql)       # For making GraphQL queries
library(dplyr)      # For data manipulation
library(ggplot2)    # For visualization
library(tidyr)      # For formatting data
```

<div style="text-align: center;">
  <img src="../../Shot_Poses_IACS/OmniacPoses_33.png" width="150"/>
</div>


## Connect to the Snapshot GraphQL API


We use `ghql` to create a client for querying the Snapshot API. We'll define the queries for:

- DAO spaces

- Proposals

- Votes

```{r graphql}
# Create a GraphQL client for Snapshot.org
# Initialize GraphQL client
con <- GraphqlClient$new("https://hub.snapshot.org/graphql")

# Prepare GraphQL queries
qry <- Query$new()

# Define queries for spaces, proposals, and votes
qry <- Query$new()

# Query for fetching DAO spaces
qry$query('space_data',
    'query space_data($skip:Int!){
        spaces(orderBy: "id", orderDirection: asc,first:1000,skip:$skip){
            id name private about avatar website twitter github coingecko email
            network symbol domain proposalsCount activeProposals followersCount
            votesCount verified flagged rank
        }
    }'
)

# Query for fetching proposals from a given space
qry$query('prop_data',
    'query prop_data($slugid: String!, $timestamp: Int!){
        proposals(orderBy: "created", orderDirection: asc,first:1000,
            where:{space:$slugid,created_gt:$timestamp}) {
            id space{id} ipfs author created network type title body start end
            state votes choices scores_state scores
        }
    }'
)

# Query for fetching individual votes for a proposal
qry$query('vote_data',
    'query vote_data($propid: String!, $timestamp: Int!){
        votes(orderBy: "created", orderDirection: asc,first:1000,
            where:{proposal:$propid,created_gt:$timestamp}) {
            id proposal{id} ipfs voter created choice vp
        }
    }'
)
```

<div style="text-align: right;">
  <img src="../../Shot_Poses_IACS/OmniacPoses_34.png" width="150"/>
</div>


## Download and Prepare Proposals

We'll now write functions to download:

- All spaces (optional, for exploration)

- All proposals in a space (filtered to two proposals of interest)

- All votes for a proposal

Each function contains step-by-step comments explaining the loop logic and purpose. We then filter the proposals to the two relevant ones for the analysis.

```{r getdata}
# Function to fetch all proposals for a given DAO space
get_proposals <- function(slug) {
  c_timestamp <- 0
  prop_data <- data.frame()
  while (TRUE) {
    pd_t <- fromJSON(con$exec(qry$queries$prop_data, list(slugid = slug, timestamp = c_timestamp)))$data$proposals
    if (length(pd_t) == 0) break
    prop_data <- bind_rows(prop_data, pd_t)
    c_timestamp <- as.numeric(tail(pd_t$created, 1))
    #message(paste0("Fetched ", nrow(prop_data), " Entries"))
  }
  prop_data$space_id <- prop_data$space$id
  prop_data$space <- NULL
  return(prop_data)
}

# Function to fetch all proposals for a given DAO space# Get proposals for Arbitrum DAO
prop_df <- get_proposals("arbitrumfoundation.eth")

# Focus on two proposals of interest
prop_df_sub <- prop_df[prop_df$id %in% c(
  "0x14e71f784e880170972572c2696ef53ef437700c637a151b5176a5827fe5b8bc",
  "0x5824d0b51cc435a49f6455ee2715216d6b958637218ed79e3e93c41af6bdef33"
), ]
```


## Download and Prepare Vote Data

This function retrieves all votes for each proposal. Pagination is used to ensure we get all data, and results are stored in a list for each proposal.

```{r getvotes}

get_votes <- function(prop) {
  c_timestamp <- 0
  vote_data <- data.frame()
  while (TRUE) {
    vd_t <- fromJSON(con$exec(qry$queries$vote_data, list(propid = prop, timestamp = c_timestamp)))$data$votes
    if (length(vd_t) == 0) break
    vote_data <- bind_rows(vote_data, vd_t)
    c_timestamp <- as.numeric(tail(vd_t$created, 1))
    #message(paste0("Fetched ", nrow(vote_data), " Entries")) # uncomment to keep track of data fetching profress
  }
  vote_data$prop_id <- vote_data$proposal$id
  vote_data$proposal <- NULL
  return(vote_data)
}

# Download votes for both proposals and combine into one dataframe
vote_l <- lapply(prop_df_sub$id, get_votes)
vote_df <- do.call(rbind, vote_l)
```


<img src="../../Shot_Poses_IACS/OmniacPoses_35.png" width="120" style="float:right; margin: 8px 0 8px 20px;">


# Analyze and Rank Statements

The next step is to calculate various summary statistics for each statement in each proposal, both by unweighted and token-weighted votes. Comments clarify every operation.
```{r computeranking}
vote_df14 <- vote_df[vote_df$prop_id == "0x14e71f784e880170972572c2696ef53ef437700c637a151b5176a5827fe5b8bc", ]
vote_df58 <- vote_df[vote_df$prop_id == "0x5824d0b51cc435a49f6455ee2715216d6b958637218ed79e3e93c41af6bdef33", ]


# Helper to unpack choices and compute stats
compute_ranking <- function(vote_df) {
  n_choices <- 10
  rankings <- do.call(rbind, lapply(vote_df$choice, function(x) match(1:n_choices, x)))
  vp_weights <- vote_df$vp / sum(vote_df$vp)

  data.frame(
    Choice = 1:n_choices,
    SumRank = apply(rankings, 2, sum),
    SumRankAvg = apply(rankings, 2, mean),
    PctFirst = sapply(1:n_choices, function(x) mean(sapply(vote_df$choice, function(z) z[1] == x))),
    PctLast = sapply(1:n_choices, function(x) mean(sapply(vote_df$choice, function(z) z[10] == x))),
    PctFirstFive = sapply(1:n_choices, function(x) mean(sapply(vote_df$choice, function(z) x %in% z[1:5]))),
    VPRankAvg = apply(rankings, 2, function(rk) sum(rk * vp_weights))
  )
}

rankraw14 <- compute_ranking(vote_df14)
rankraw58 <- compute_ranking(vote_df58)

# Display result tables (add your statement labels for final output)
knitr::kable(rankraw14[order(rankraw14$SumRank), ], caption = "Growth & Innovation Rankings")
knitr::kable(rankraw58[order(rankraw58$SumRank), ], caption = "Reducing Friction Rankings")
```

<img src="../../Shot_Poses_IACS/OmniacPoses_38.png" width="120" style="float:left; margin: 8px 0 8px 20px;">

## Discussion and Insights
Example Interpretation
For "Reducing Friction", "Prioritize Gas Fee Optimization" was ranked highest when votes are equally weighted.

When votes are weighted by tokens, "Build a robust community of developers" rises to the top.

This shows that community and large holders align on the top priorities, but token weighting can shift the relative importance of specific statements.

Visualizing Rankings
```{r}
plot_ranking <- function(rankdf, title) {
  df <- rankdf %>%
    mutate(Statement = factor(Choice, labels = paste("Choice", 1:10))) %>%
    pivot_longer(cols = c(SumRankAvg, VPRankAvg), names_to = "Type", values_to = "Value")
  ggplot(df, aes(x = Statement, y = Value, fill = Type)) +
    geom_bar(stat = "identity", position = "dodge") +
    theme_minimal() +
    labs(title = title, y = "Average Rank", x = "") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

plot_ranking(rankraw14, "Growth & Innovation: Equal vs Token Weighted Rankings")
plot_ranking(rankraw58, "Reducing Friction: Equal vs Token Weighted Rankings")

```

<div style="text-align: center;">
  <img src="../../Shot_Poses_IACS/OmniacPoses_36.png" width="150"/>
</div>


# OpenAI Analysis

In this section, we integrate advanced language modeling into our DAO voting analysis. While previous sections relied on deterministic statistical aggregation, here we leverage OpenAI’s GPT-4o-mini model to synthesize a group consensus ranking from raw voting data. This approach introduces a qualitative perspective and allows us to compare traditional quantitative methods with the “collective intelligence” that an LLM might infer from observed voter preferences.


<div style="text-align: right;">
  <img src="../../Shot_Poses_IACS/OmniacPoses_37.png" width="150"/>
</div>

## Extracting Choice Labels Programmatically

Before we can prompt OpenAI, we need to translate the numeric rankings from each voter back to their original statement text. The statement text for each ranked-choice poll is stored in the proposal body field, but not in a direct table. The following function automates extraction by parsing the proposal text for enumerated statements. This ensures our analysis is robust and future-proof, as it adapts to any poll with statements following a consistent numbering format.

```{r}

# Extracts the choice labels (statements) from a Snapshot proposal's body text
extract_choice_labels <- function(proposal_body) {
  # Try to find the block starting with "\nThese are the statements:\n" or similar
  start_idx <- regexpr("These are the statements:", proposal_body)
  if (start_idx == -1) stop("Can't find statement block in proposal body")

  # Extract from that point to the end
  statements_block <- substring(proposal_body, start_idx)

  # Find all lines starting with '1.', '2.', ..., '10.' (robust for up to 10)
  lines <- unlist(strsplit(statements_block, "\n"))
  # Only keep lines starting with digit + dot
  choice_lines <- grep("^[0-9]+\\. ", lines, value = TRUE)
  # Remove "1. " etc
  labels <- sub("^[0-9]+\\.\\s*", "", choice_lines)
  return(labels)
}

# Example: for vote_df14 (growth & innovation)
proposal_id_14 <- unique(vote_df14$prop_id) # should be just one value
proposal_body_14 <- prop_df_sub$body[prop_df_sub$id == proposal_id_14]
choice_labels_14 <- extract_choice_labels(proposal_body_14)

# For vote_df58 (reducing friction)
proposal_id_58 <- unique(vote_df58$prop_id)
proposal_body_58 <- prop_df_sub$body[prop_df_sub$id == proposal_id_58]
choice_labels_58 <- extract_choice_labels(proposal_body_58)
```

## Building a Consensus Ranking Prompt for OpenAI
To minimize costs and maximize efficiency when using the OpenAI API, we sample a subset of the available voter rankings. This random sampling reduces the number of tokens sent, while still capturing the main trends in voter sentiment. The following function packages this sample, constructs a precise API prompt, and defines exactly how we expect GPT-4o-mini to return results. Importantly, the prompt asks the model not just for a ranking, but also for a brief explanation of its methodology—providing valuable transparency into its “reasoning” process.

```{r}
# Main function: Get consensus ranking using OpenAI
get_consensus_ranking <- function(vote_df, prop_df_sub, n_sample = 30, api_key_path = "your_openai_key.txt") {
  # a. Find proposal body for this vote_df
  proposal_id <- unique(vote_df$prop_id)
  proposal_body <- prop_df_sub$body[prop_df_sub$id == proposal_id]
  if (length(proposal_body) != 1) stop("Proposal body not found or ambiguous!")
  choice_labels <- extract_choice_labels(proposal_body)

  # b. Prepare numeric rankings (sample for token efficiency)
  numeric_rankings_text <- sapply(vote_df$choice, function(x) paste(x, collapse = ","))
  set.seed(42)
  sample_idx <- sample(seq_along(numeric_rankings_text), min(n_sample, length(numeric_rankings_text)))
  sampled_rankings <- numeric_rankings_text[sample_idx]
  all_numeric_text <- paste(sampled_rankings, collapse = "\n")

  # Build minimal prompt for OpenAI
  prompt <- paste(
    "You are an expert at group consensus analysis.",
    "Below are multiple ranked lists of choices, each a permutation of the numbers 1–10, where each line is a different voter.",
    "Each number corresponds to a unique statement (but you do not need to know the statements).",
    "",
    "Each line is the ranked order for one voter (first is most preferred, last is least):",
    all_numeric_text,
    "",
    "Your tasks:",
    "1. Based only on these rankings, synthesize a single consensus ranking (as a permutation of 1–10) that best reflects the collective preference.",
    "2. Output ONLY the consensus ranking as your first line, in the following format (with no explanation before):",
    "Consensus: x1,x2,x3,x4,x5,x6,x7,x8,x9,x10",
    "3. After the ranking, in 2-4 sentences, explain *how* you synthesized this ranking: mention if you averaged positions, looked for patterns, considered polarization, etc. Focus on what you observed in the rankings, not the meaning of the numbers."
  )



  # Send to OpenAI API (requires API key in a text file)
  openai_api_key <- readLines(api_key_path)
  response <- POST(
    url = "https://api.openai.com/v1/chat/completions",
    add_headers(Authorization = paste("Bearer", openai_api_key)),
    content_type_json(),
    body = toJSON(list(
      model = "gpt-4o-mini", # or any preferred model
      messages = list(list(role = "user", content = prompt)),
      temperature = 0.2,
      max_tokens = 100
    ), auto_unbox = TRUE)
  )

  # Parse response, map consensus to text
  result <- fromJSON(rawToChar(response$content))
  content <- result$choices$message$content
  lines <- unlist(strsplit(content, "\n"))
  num_line <- grep("^Consensus:", lines, value = TRUE)[1]
  if (is.na(num_line)) {
    cat("No consensus ranking found in the model output.\n")
    print(content)
    return(NULL)
  }
  consensus_numeric <- gsub("[^0-9,]", "", num_line)
  consensus_ids <- as.integer(unlist(strsplit(consensus_numeric, ",")))
  consensus_statements <- choice_labels[consensus_ids]

  cat("Consensus Ranking (Numbers):\n", consensus_numeric, "\n\n")
  cat("Consensus Ranking (Statements):\n")
  for (i in seq_along(consensus_statements)) {
    cat(sprintf("Rank %d: Choice %d: %s\n", i, consensus_ids[i], consensus_statements[i]))
  }
  cat("\n---\n")
  cat("OpenAI Model Explanation:\n")
  explanation <- paste(lines[(which(lines == num_line)+1):length(lines)], collapse = "\n")
  cat(explanation, "\n")
  return(consensus_statements)


}
```

<div style="text-align: left;">
  <img src="../../Shot_Poses_IACS/OmniacPoses_39.png" width="150"/>
</div>

## Calling the GPT-4o-mini Consensus Function

Now, we call our custom function, passing in the appropriate vote and proposal data. The output will include both the ranked statements (mapped from the original choice indices) and the model's brief explanation of its ranking strategy.

By comparing these results to our deterministic, token-weighted rankings, we can highlight the differences between a purely statistical aggregation and the type of pattern recognition and consensus modeling performed by a state-of-the-art language model. This comparison adds another layer of interpretability to our study and offers a compelling way to triangulate DAO preferences.

*Note: API costs can scale with prompt size, so be mindful of your sample size and your OpenAI account limits.*

### Interpretation
The GPT-4o-mini model's ranking is sometimes different from our classic deterministic aggregation. This is partly due to random sampling (to save tokens/cost) but also reflects the LLM's ability to weigh not only strict averages but also patterns in the distribution of ranks—such as consistency, outliers, and relative ordering trends. Its brief "reasoning" section can highlight patterns we might otherwise miss, making it a useful supplement to classic data science methods.



```{r, warning = FALSE}
# -- For proposal 14 (Growth & Innovation) --
consensus_14 <- get_consensus_ranking(vote_df14, prop_df_sub, n_sample = 500, api_key_path = "../../openai_key.txt")

# -- For proposal 58 (Reducing Friction) --
consensus_58 <- get_consensus_ranking(vote_df58, prop_df_sub, n_sample = 500, api_key_path = "../../openai_key.txt")

```

<div style="text-align: right;">
  <img src="../../Shot_Poses_IACS/OmniacPoses_41.png" width="150"/>
</div>


# Conclusions

This analysis provides a comprehensive framework for quantifying and understanding alignment between large token holders and the broader Arbitrum DAO community with respect to strategic priorities. By examining both equal-weighted (one wallet, one vote) and token-weighted (voting power) rankings, we are able to reveal not only the overall consensus but also to highlight potential divergences between high-stake holders and general participants.

Through classic statistical aggregation, we demonstrated which statements consistently ranked at the top across different voting schemes, thereby identifying areas of strong community consensus. Conversely, discrepancies between the two schemes can help surface priorities that are particularly important to either major stakeholders or the broader base, informing more inclusive decision-making processes.

In addition to these quantitative approaches, we integrated OpenAI's state-of-the-art language model (GPT-4o-mini) into our workflow. By prompting the AI with real anonymized voting records, we obtained an AI-synthesized consensus ranking and a concise explanation of the logic behind the ordering. This adds a qualitative layer of analysis that can capture subtle patterns—such as clustering, polarization, or emergent trends in ranking behavior—that might be overlooked by traditional methods. The AI explanation also enhances transparency and interpretability, offering an alternative lens for both researchers and governance participants.

Our methodology is generalizable and can be readily applied to other DAO governance polls and ranking-based decision scenarios. By blending statistical analysis with AI-based synthesis, we offer a richer, multidimensional perspective on community preferences—empowering DAOs to make more informed, balanced, and democratic decisions.

*In summary, combining traditional ranking analytics with modern AI tools not only validates results through multiple lenses but also brings greater transparency and insight into complex governance ecosystems like Arbitrum DAO.*

